<!--
 https://github.com/stevenrskelton/d3-datamaps
-->

<script src="js/topojson/topojson.v1.min.js"></script>
<script src="js/datamaps/datamaps.js"></script>

<polymer-element name="d3-datamaps" attributes="selected data hover clicked map theme multiselect zoom hoverTemplate rootDirectory">
  <template>
	<style>
		:host { display: block; }
	</style>
	<div id="container" style="position:relative;"></div>
  </template>
  <script>

	var defaultTheme = {
		defaultFill: '#ABDDA4',
		defaultSelectedFill: '#FBB917',
		backgroundColor: 'transparent',
		borderWidth: 1,
		borderColor: '#FDFDFD',
		highlightFillColor: '#FC8D59',
		highlightBorderColor: 'rgba(250, 15, 160, 0.2)',
		highlightBorderWidth: 2,
		cursor: 'pointer',
		backgroundImage: 'none',
		backgroundPositionX: 0,
		backgroundPositionY: 0
	};

	function reformatProjection(zoom, map){
		if(zoom){
			if ( map === 'usa' ) {
				return function(element){
					var scale = element.offsetWidth;
					if(zoom.scale) scale = scale * zoom.scale / 100;

					projection = d3.geo.albersUsa()
						.scale(scale)
						.translate([element.offsetWidth / 2, element.offsetHeight / 2]);

					var path = d3.geo.path()
						.projection(projection);

					return {path: path, projection: projection};
				}
			} else if ( map === 'world' ) {
				return function(element) {
					var scale = (element.offsetWidth + 1) / 2 / Math.PI;
					if(zoom.scale) scale = scale * zoom.scale / 100;

					var projection = d3.geo.equirectangular()
						.center([zoom.x || 0, zoom.y || 0])
						.scale(scale)
						.translate([element.offsetWidth / 2, element.offsetHeight / 1.82]);
					var path = d3.geo.path()
						.projection(projection);

					return {path: path, projection: projection};
				}
			}
		}else return null;
	}

	Polymer('d3-datamaps', {
		rootDirectory: '../src/',
		d3map: null,
		hover: null,
		data: null,
		map: 'world',
		multiselect: false,
		theme: {
			defaultFill: defaultTheme.defaultFill,
			defaultSelectedFill: defaultTheme.defaultSelectedFill,
			backgroundColor: defaultTheme.backgroundColor,
			borderWidth: defaultTheme.borderWidth,
			borderColor: defaultTheme.borderColor,
			highlightFillColor: defaultTheme.highlightFullColor,
			highlightBorderColor: defaultTheme.highlightBorderColor,
			highlightBorderWidth: defaultTheme.highlighBorderWidth,
			cursor: defaultTheme.cursor,
			backgroundImage: defaultTheme.backgroundImage,
			backgroundPositionX: defaultTheme.backgroundPositionX,
			backgroundPositionY: defaultTheme.backgroundPositionY
		},
		attached: function(){
			var self = this;

			//fill parent element
			if(this.clientWidth>0){
				var height = this.clientHeight;
				if(height < 64){
					if(self.map=='world') height = this.clientWidth * 0.43;
					else if(self.map=='usa') height = this.clientWidth * 0.465;
				}
				this.$.container.style.height = height + 'px';
			}

			//zoom
			var projection = reformatProjection(this.zoom, self.map);

			//theme
			this.$.container.style.backgroundColor = this.theme.backgroundColor || defaultTheme.backgroundColor;
			this.$.container.style.cursor = this.theme.cursor || defaultTheme.cursor;
			//this.renderBackgroundImage();

			this.d3map = new Datamap({
				element: this.$.container,
				scope: self.map,
				fills: {
					defaultFill: self.theme.defaultFill
				},
				data: self.data || {},
				setProjection: projection,
				geographyConfig: {
					dataUrl: self.rootDirectory + '/js/datamaps/' + self.map + '.topo.json', //if not null, datamaps will fetch the map JSON (currently only supports topojson)
					hideAntarctica: false,
					borderWidth: self.theme.borderWidth || defaultTheme.borderWidth,
					borderColor: self.theme.borderColor || defaultTheme.borderColor,
					popupTemplate: function(geography, data) { //this function should just return a string
						if(!self.hover || self.hover.geography.id != geography.id) self.hover = { geography: geography, data: data };
						if(self.hoverTemplate){
							 return self.hoverTemplate(geography, data);
						}else{
							return '<div class="hoverinfo"><strong>' + geography.properties.name + '</strong></div>';
						}
					},
					popupOffHover: function(){
						self.hover = null;
					},
					popupOnHover: true, //disable the popup while hovering
					highlightOnHover: true,
					highlightFillColor: self.theme.highlightFillColor || defaultTheme.highlightFillColor,
					highlightBorderColor: self.theme.highlightBorderColor || defaultTheme.highlightBorderColor,
					highlightBorderWidth: self.theme.highlightBorderWidth || defaultTheme.highlighBorderWidth
				},
				done: function(datamap) {
					var subunits = datamap.svg.selectAll('.datamaps-subunit');
					subunits.on('click', function(geography) {
						self.itemClicked(geography);
					});
					self.selectedChanged(null,self.selected);
					var observer = new ObjectObserver(self.selected);
					observer.open(function(added, removed, changed, getOldValueFn) {
						if(self.d3map){
							var cleared = self.theme.defaultFill || defaultTheme.defaultFill;;
							var defaultSelectedFill = self.theme.defaultSelectedFill || defaultTheme.defaultSelectedFill;
							var selectedToFill = {};
							Object.keys(removed).forEach(function(property) {
								//check if it's in data
								var data;
								if(self.data) data = self.data[property];
								if(data){
									data.color = cleared;
									selectedToFill[property] = data;
								}else{
									var oldVal = getOldValueFn(property);
									oldVal.color = cleared;
									selectedToFill[property] = oldVal;
								}
							});
							// respond to changes to the obj.
							Object.keys(added).forEach(function(property) {
								if(typeof added[property] === 'string'){
									selectedToFill[property] = { color: added[property] };
								}else{
									selectedToFill[property] = added[property];
								}
							});
							Object.keys(changed).forEach(function(property) {
								if(typeof changed[property] === 'string'){
									selectedToFill[property] = { color: changed[property] };
								}else{
									selectedToFill[property] = changed[property];
								}
							});
							self.d3map.updateChoropleth(selectedToFill);
						}
					});
					var g = datamap.svg.select('g.datamaps-subunits')[0][0];
					g.addEventListener("translation", function() { self.renderBackgroundImage.call(self); });
					self.renderBackgroundImage.call(self);
				}
			});
			this.d3map.userMovement();
			this.d3map.background();
		},
		itemClicked: function(geography){
			var data = {};
			//find record
			var d = this.data;
			for (var key in d) {
				if (d.hasOwnProperty(key) && key == geography.id) {
					data = d[key]
					break;
				}
			}
			this.fire('clicked', { geography: geography, data: data });

			if(this.multiselect){
				var color = this.theme.highlightFillColor || defaultTheme.highlightFillColor;
				var s = this.selected || {};
				var n = {};

				if(!s[geography.id]) n[geography.id] = color;

				for (var key in s) {
					if (s.hasOwnProperty(key) && key!=geography.id){
						n[key] = color;
					}
				}
				this.selected = n;
			}
		},
		selectedChanged: function(oldVal, newVal) {
			if(this.d3map){
				var cleared = this.theme.defaultFill;
				var defaultSelectedFill = this.theme.defaultSelectedFill;
				var selectedToFill = {};

				//clear old
				if(oldVal){
					for (var key in oldVal) {
						if (oldVal.hasOwnProperty(key)) {
							//check if it's in data
							var data;
							if(this.data) data = this.data[key];
							if(data){
								data.color = cleared;
								selectedToFill[key] = data;
							}else{
								oldVal.color = cleared;
								selectedToFill[key] = oldVal;
							}
						}
					}
					//handle array
					if(oldVal.length>0){
						for(var i=0;i<oldVal.length;i++){
							var key = oldVal[i];
							//check if it's in data
							var data;
							if(this.data) data = this.data[key];
							if(data){
								data.color = cleared;
								selectedToFill[key] = data;
							}else{
								selectedToFill[key] = cleared;
							}
						}
					}
				}
				//fill new
				if(newVal){
					if(newVal.length>0){
						//handle array
						for(var i=0;i<newVal.length;i++){
							selectedToFill[newVal[i]] = defaultSelectedFill;
						}
					}else{
						for (var key in newVal) {
							if (newVal.hasOwnProperty(key)) {
								if(typeof newVal[key] === 'string'){
									selectedToFill[key] = { color: newVal[key] };
								}else{
									selectedToFill[key] = newVal[key];
								}
							}
						}
					}
				}
				this.d3map.updateChoropleth(selectedToFill);
			}
		},
		observe: {
			'zoom.x': 'zoomChanged',
			'zoom.y': 'zoomChanged',
			'zoom.scale': 'zoomChanged'
		},
		zoom: {
			x: 0,
			y: 0,
			scale: 100
		},
		zoomChanged: function(oldVal, newVal){
			if(this.d3map){
				if(this.theme.backgroundImage!='none'){
					//scale
					this.renderBackgroundImage();
				}
				this.d3map.setProjection = reformatProjection(this.zoom, this.map);
				this.d3map.transitionProjection();
			}
		},
		renderBackgroundImage: function(){
			if(this.theme.backgroundImage != 'none' && this.d3map){
				//if(this.d3map){
				var svg = this.d3map.svg;
				var image //= svg.querySelector('image');
				if(image){
				
				}
				//console.log('svg');
				//console.log(svg);
				/*
				
				this.$.container.style.backgroundImage = this.theme.backgroundImage;

				var translatedPositionX = this.theme.backgroundPositionX || defaultTheme.backgroundPositionX;
				var translatedPositionY = this.theme.backgroundPositionY || defaultTheme.backgroundPositionY;

				var scale = this.zoom.scale / 100;
				var width = this.$.container.offsetWidth;
				var height2 = width * 0.43;
				var height = this.$.container.offsetHeight;

				//zoom
				translatedPositionX = (( width  - (scale * width  )) / 2) - (translatedPositionX * scale) - (( this.zoom.x || 0 ) / 360 * scale * width        );
				translatedPositionY = (( height - (scale * height2)) / 2) - (translatedPositionY * scale) + (( this.zoom.y || 0 ) / 360 * scale * (height - 24)) - (30.3 * scale) + (15.3 * height / height2) - 11;

				//svg transform
				if(this.d3map){
					var g = this.d3map.svg[0][0].querySelector('g.datamaps-subunits');
					function getScale(){
						//var g = svg.select('g.datamaps-subunits')[0][0];
						var s = g.transform.baseVal.getItem(0);
						var sx = 0, sy = 0;
						if (s.type == SVGTransform.SVG_TRANSFORM_SCALE){
							sx = s.matrix.a;
							//sy = s.matrix.d;
						}
						return sx;
					}
					function getTranslation(){
						//var g = svg.select('g.datamaps-subunits')[0][0];
						var t = g.transform.baseVal.getItem(1);
						var tx = 0, ty = 0;
						if (t.type == SVGTransform.SVG_TRANSFORM_TRANSLATE){
							tx = t.matrix.e;
							ty = t.matrix.f;
						}
						return {x: tx, y:ty};
					}
					console.log(getScale());
					scale *= getScale();
					var translation = getTranslation();
					translatedPositionX += translation.x;
					translatedPositionY += translation.y;
				}
				
				this.$.container.style.backgroundSize =  width * scale + 'px';
				this.$.container.style.backgroundPosition = translatedPositionX + 'px ' + translatedPositionY + 'px';*/
			}
		}
	});
  </script>    
</polymer-element>